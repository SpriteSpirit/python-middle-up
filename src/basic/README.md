## Аннотации типов
**Аннотации типов в Python** — это способ указания типов переменных, параметров функций и возвращаемых значений. 
Они не влияют на выполнение кода, но помогают разработчикам понимать структуру кода, улучшают читаемость и облегчают 
обнаружение ошибок с помощью инструментов статической типизации, таких как `mypy`.

**Преимущества:**
- Улучшенная читаемость кода.
- Помощь в обнаружении ошибок на этапе разработки.
- Поддержка автодополнения в IDE.
- Документация типов для функций и методов.

```python
def greet(name: str) -> str:
    return f"Hello, {name}!"

message: str = greet("Alice")
print(message)
```

- Аннотации типов добавляются с помощью синтаксиса `: type` для параметров и `-> type` для возвращаемого значения.
- Для обозначения типов, которые могут принимать значение `None`, используется `Optional` из модуля `typing`. 
- `Optional[X]` эквивалентно `Union[X, None]`.

```python
from typing import Optional

def find_user(user_id: int) -> Optional[str]:
    users = {1: "Alice", 2: "Bob"}
    return users.get(user_id)

user: Optional[str] = find_user(3)
print(user)  # Выведет: None
```

- `Union` из модуля `typing` позволяет указать, что переменная может быть одного из нескольких типов.

```python
from typing import Union

def process(value: Union[int, float]) -> float:
    return float(value) * 2

print(process(5))    # Выведет: 10.0
print(process(3.5))  # Выведет: 7.0
```

- Коллекции аннотируются с помощью обобщенных типов. Например: `list`, `dict`

```python
def process_numbers(numbers: list[int]) -> int:
    return sum(numbers)

def get_user_info() -> dict[str, str]:
    return {"name": "Alice", "email": "alice@example.com"}


print(process_numbers([1, 2, 3]))          # Выведет: 6
print(get_user_info())                     # Выведет: {'name': 'Alice', 'email': 'alice@example.com'}

```

- `Any` из модуля typing используется, когда тип переменной неизвестен или может быть любым. 
- Однако его следует использовать с осторожностью, так как он отключает проверку типов для этой переменной.

```python
from typing import Any

def process(data: Any) -> None:
    print(data)

process(10)          # Выведет: 10
process("Hello")     # Выведет: Hello
process([1, 2, 3])   # Выведет: [1, 2, 3]
```

- `TypeVar` из модуля `typing` позволяет создавать обобщенные типы, которые могут использоваться для аннотации функций, принимающих различные типы данных.
- `Обобщённые функции` — это функции, которые могут работать с разными типами данных, например, списками чисел или строк. 
- В `Python` это достигается с помощью аннотаций типов и `TypeVar`, который задаёт переменную типа `T`, которая может быть любым типом.


```python
from typing import TypeVar, List

T = TypeVar('T')

def get_first_element(elements: List[T]) -> T:
    return elements[0]

print(get_first_element([1, 2, 3]))        # Выведет: 1
print(get_first_element(["a", "b", "c"]))  # Выведет: a
```
#### Объяснение:
- Для создания обобщённых функций в Python, работающих с разными типами данных, используется `TypeVar` из модуля `typing`. 
- Это позволяет функции быть универсальной и проверять типы статически.
- В примере `get_first_element` `T` — это переменная типа, которая может быть `int` или `str`, в зависимости от входного списка.
- При вызове с целыми числами, например [1, 2, 3], `T` становится `int`, и функция возвращает число.
- При вызове со строками, например ["a", "b", "c"], `T` становится `str`, и функция возвращает строку.
- Это помогает избежать ошибок, например, попытки сложить число и строку, что вызовет ошибку типовой проверки
- Такой подход помогает избежать ошибок типов на этапе разработки, особенно если использовать инструменты проверки типов, такие как mypy. 
- Например, если передать список смешанных типов, например [1, "a"], типовая проверка может выдать ошибку, хотя код выполнится на этапе выполнения.


- `mypy` — это статический типизатор для Python, который проверяет соответствие кода аннотациям типов. 
- Он помогает обнаруживать ошибки типов до выполнения программы.

### Аннотации атрибутов классов и методов внутри классов

- Аннотации типов в классах указываются для атрибутов и методов аналогично функциям. 
- Для методов используется `self` как первый параметр.

```python

class Person:
    name: str
    age: int
    friends: list[str]

    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age
        self.friends = []

    def add_friend(self, friend_name: str) -> None:
        self.friends.append(friend_name)

alice = Person("Alice", 30)
alice.add_friend("Bob")
print(alice.friends)  # Выведет: ['Bob']

```

### Аннотация словарей с определенной структурой ключей и типов значений
- `TypedDict` из модуля `typing` позволяет создавать типизированные словари с фиксированными ключами и типами значений, что улучшает проверку типов и автодополнение.

```python
from typing import TypedDict

class User(TypedDict):
    name: str
    age: int
    email: str

def create_user(user: User) -> None:
    print(f"Name: {user['name']}, Age: {user['age']}, Email: {user['email']}")

user_data: User = {
    "name": "Alice",
    "age": 30,
    "email": "alice@example.com"
}

create_user(user_data)
```

- Проверка с `mypy` - Если пропустить обязательный ключ или указать неправильный тип:

```python
user_data_incorrect = {
    "name": "Bob",
    "age": "twenty-five",  # Ошибка: ожидается int
    "email": "bob@example.com"
}

create_user(user_data_incorrect)
```

### Дополнительные темы для изучения:
- Пользовательские типы и наследование типов: Использование NewType и наследование от существующих типов.
- Аннотация типов для генераторов и асинхронных функций: Использование Generator, AsyncGenerator.
- Строгий режим mypy: Включение дополнительных проверок для повышения строгости типизации.
- Интеграция mypy в CI/CD пайплайны: Автоматизация проверки типов при сборке и деплое.
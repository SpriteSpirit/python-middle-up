## OLTP и OLAP базы данных
`OLTP (Online Transaction Processing)` и `OLAP (Online Analytical Processing)` — 
это два типа систем баз данных, которые используются для разных целей и задач.

### OLTP (Online Transaction Processing)
`OLTP-системы` предназначены для обработки транзакций в реальном времени. 
Они оптимизированы для выполнения множества коротких операций, таких как вставка, обновление и удаление данных. 

### Основные характеристики OLTP-систем:
* **Высокая скорость обработки:** OLTP-системы должны быстро обрабатывать большое количество транзакций.
* **Целостность данных:** Обеспечивают целостность данных за счет использования механизмов ACID (Atomicity, Consistency, Isolation, Durability).
* **Мелкие транзакции:** Обычно каждая транзакция затрагивает небольшое количество данных.
* **Примеры использования:** Банковские операции, интернет-магазины, системы бронирования билетов.
* **Примеры OLTP-систем:** MySQL, PostgreSQL, Microsoft SQL Server, Oracle.

### OLAP (Online Analytical Processing)
`OLAP`-системы предназначены для аналитической обработки данных. Они оптимизированы для выполнения сложных запросов, 
которые могут затрагивать большие объемы данных. 

### Основные характеристики OLAP-систем:
* **Аналитика и отчеты:** `OLAP`-системы используются для анализа данных, генерации отчетов и принятия решений.
* **Большие объемы данных:** Они работают с большими объемами данных, часто агрегированными.
* **Сложные запросы:** `OLAP`-запросы могут быть сложными и требовать много времени для выполнения.
* **Примеры использования:** Бизнес-аналитика, анализ продаж, прогнозирование.
* **Примеры `OLAP`-систем:** Microsoft Analysis Services, Oracle Essbase, IBM Cognos, SAP BW.

### Основные различия между OLTP и OLAP
* **Цель:** `OLTP` — обработка транзакций, `OLAP` — анализ данных.
* **Тип операций:** `OLTP` — короткие операции, `OLAP` — сложные запросы.
* **Объем данных:** `OLTP` — небольшие объемы данных на транзакцию, `OLAP` — большие объемы данных.
* **Скорость**: `OLTP` — высокая скорость обработки транзакций, `OLAP` — высокая скорость выполнения сложных запросов.
* **Целостность данных:** `OLTP` — строгая целостность данных, `OLAP` — целостность данных менее критична.


### Пример использования
`OLTP:` Интернет-магазин обрабатывает заказы клиентов, обновляет данные о наличии товаров и регистрирует платежи.

`OLAP:` Аналитик использует данные из интернет-магазина для анализа продаж, прогнозирования спроса и выявления тенденций.

Таким образом, `OLTP` и `OLAP` системы дополняют друг друга и используются в разных сценариях работы с данными.


## Уровни изоляции баз данных
Уровни изоляции в базах данных определяют, как транзакции взаимодействуют друг с другом и какие аномалии могут возникать. 

### Основные уровни изоляции:
`Read Uncommitted (Чтение незафиксированных данных):`
Транзакции видят незафиксированные изменения других транзакций.
Возможны аномалии: "грязное чтение" (чтение неверных данных).

`Read Committed (Чтение зафиксированных данных):`
Транзакции видят только зафиксированные данные.
Исключает "грязное чтение", но возможны аномалии: "неповторяющееся чтение" (данные могут измениться при повторном чтении).

`Repeatable Read (Повторяемое чтение):`
Гарантирует, что данные, прочитанные в транзакции, не изменятся до её завершения.
Исключает "грязное чтение" и "неповторяющееся чтение", но возможны аномалии: "фантомное чтение" (появление новых строк).

`Serializable (Сериализуемый):`
Самый строгий уровень. Транзакции выполняются так, как будто они идут одна за другой.
Исключает все аномалии: "грязное чтение", "неповторяющееся чтение" и "фантомное чтение".

### Кратко:
`Read Uncommitted:` Грязное чтение возможно.
`Read Committed:` Грязное чтение исключено, но возможны изменения данных.
`Repeatable Read:` Данные не изменяются, но могут появляться новые строки.
`Serializable:` Полная изоляция, никаких аномалий.

Чем выше уровень изоляции, тем больше гарантий целостности данных, но ниже производительность из-за блокировок.

## Транзакции
**Транзакция** — это группа операций в базе данных, которые выполняются как единое целое. Она либо выполняется полностью, 
либо не выполняется вообще. 

### Основные свойства транзакций описываются принципом ACID:
* `Атомарность (Atomicity):` Все операции транзакции выполняются или ни одна.
* `Согласованность (Consistency):` Транзакция переводит базу данных из одного корректного состояния в другое.
* `Изолированность (Isolation):` Транзакции не мешают друг другу.
* `Долговечность (Durability):` Результаты выполненной транзакции сохраняются даже после сбоев.

`Пример:` Перевод денег между счетами. Списание с одного счета и зачисление на другой должно произойти одновременно. 
Если что-то пошло не так, всё отменяется.

## WAL журналы
`WAL (Write-Ahead Logging)` — это механизм, при котором все изменения в базе данных сначала записываются в журнал (лог), 
а только потом применяются к самим данным. Это нужно для:

* `Надежности:` Если произойдет сбой, данные можно восстановить из журнала.
* `Скорости:` Запись в журнал обычно быстрее, чем обновление данных на диске.


**Коротко:** 

`WAL` — это журнал изменений, который гарантирует, что данные не потеряются даже при сбоях.

**Пример использования:**

`Представим транзакцию в интернет-магазине:`

Клиент оформляет заказ. 
Прежде чем изменения (например, уменьшение количества товара на складе) будут записаны в основной набор данных, 
они записываются в журнал `WAL`. После этого транзакция считается зафиксированной. Если произойдет сбой до записи 
изменений в основную базу, при перезапуске система прочитает журнал и завершит недостающие операции.

**Особенности WAL:**

`Ротация журналов:` Журналы транзакций могут занимать много места. Поэтому по мере применения записанных в 
журнале данных к основной базе, старые журналы удаляются или архивируются.

`Отложенная запись:` В некоторых системах `WAL` позволяет выполнять основную запись данных позже, что снижает 
нагрузку на диск и позволяет более эффективно работать с большими объемами данных.
WAL активно используется в таких СУБД, как `PostgreSQL`, `MySQL` (с включенным `InnoDB`), и других, где важны 
надежность и консистентность данных.

## SELECT ... FOR UPDATE
`SELECT ... FOR UPDATE` — это команда в `SQL`, которая блокирует выбранные строки (или таблицы) для изменения другими 
транзакциями до завершения текущей транзакции.

**Зачем нужно?**

Чтобы предотвратить изменение этих строк другими транзакциями, пока вы с ними работаете. 
Например, если вы хотите обновить данные, которые сначала нужно прочитать.

**Коротко:** 

Блокирует строки для изменения, чтобы их не могли изменить другие транзакции, пока не завершится работа с текущей.

### SELECT FOR UPDATE работает так:

* **Выбор строк:** Выполняет обычный `SELECT`, чтобы выбрать нужные строки.
* **Блокировка строк:** Этот тип блокировки называется "эксклюзивной блокировкой". 
Это означает, что строки заблокированы для изменений (`INSERT`, `UPDATE`, `DELETE`) другими транзакциями до тех пор, 
пока текущая транзакция не завершится.
* **Удержание блокировки:** Блокировка сохраняется до конца текущей транзакции (`COMMIT` или `ROLLBACK`).
* **Доступ для других:** Другие транзакции могут читать эти строки, но не могут их изменять или блокировать.

**Коротко:** 

Выбирает строки и блокирует их для изменения, пока транзакция не завершится.
Оператор обычно используется в контексте транзакций для обеспечения согласованности данных. 
Он помогает избежать конкуренции между транзакциями, работающими с одними и теми же данными.

```sql
BEGIN;

-- Блокируем строки, чтобы избежать одновременных изменений
SELECT balance FROM accounts WHERE account_id = 1 FOR UPDATE;
SELECT balance FROM accounts WHERE account_id = 2 FOR UPDATE;

-- Выполняем перевод
UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

COMMIT;
```

### Преимущества SELECT FOR UPDATE:
* `Предотвращение состояний гонки:` Гарантирует, что только одна транзакция сможет изменять выбранные строки, исключая возможность некорректных изменений из-за конкурентного доступа.
* `Согласованность данных:` Убедитесь, что данные, с которыми работает транзакция, не изменяются до завершения работы.
* `Безопасные обновления: `Обеспечивает, что операция обновления данных происходит корректно и последовательно.


### Особенности:
* `Блокировка до конца транзакции:` Строки остаются заблокированными до тех пор, пока транзакция не завершится, что может увеличить время ожидания для других транзакций, пытающихся изменить те же строки.
* `Неявное ожидание:` Если другая транзакция уже заблокировала строки, текущая транзакция будет ожидать завершения предыдущей, что может привести к задержкам.

## Redis. Основные сценарии использования
`Redis (Remote Dictionary Server)` — это высокопроизводительная `in-memory` база данных, 
которая используется как `key-value` хранилище. Она поддерживает различные структуры данных, 
такие как строки, хэши, списки, множества, отсортированные множества и другие. 

`Redis` работает в оперативной памяти, что обеспечивает высокую скорость доступа к данным, 
но также поддерживает возможность сохранения данных на диск для восстановления после перезапуска.

### Основные сценарии использования:

* `Кэширование` — ускорение доступа к данным.
* `Хранение сессий` — быстрый доступ к данным пользователей.
* `Очереди задач` — обработка фоновых задач.
* `Счетчики и аналитика` — подсчет метрик.
* `Pub/Sub` — обмен сообщениями в реальном времени.
* `Геоданные` — работа с локациями.
* `Рейтинги` — хранение и обновление рейтингов.
* `Временные данные` — хранение данных с ограниченным сроком жизни.

`Плюсы: `высокая скорость, поддержка разных структур данных, простота.

`Минусы:` ограниченный объем (память), не подходит для сложных запросов.

### Поточность
`Redis` работает в один поток для обработки команд. 
Это означает, что все команды выполняются последовательно, одна за другой. 
Основная причина такого подхода заключается в том, что это упрощает архитектуру и избавляет от 
необходимости управления блокировками, конкурентным доступом и возможными проблемами, связанными 
с многопоточностью.

#### Почему `Redis` однопоточный?

**Простота кода**: 

Однопоточный подход позволяет `Redis` избегать сложных проблем синхронизации, что делает его более надежным.

**Высокая скорость операций:** 

Основное время уходит на операции ввода-вывода (сетевые и операции с памятью), 
которые и так занимают большую часть времени. Использование однопоточной модели позволяет 
`Redis` эффективно справляться с высоким объемом операций на основе моделей кэширования в оперативной памяти.


### Типы данных в Redis
**1. Строки (Strings)**  
- **Описание:** Хранение простых значений: текст, числа, бинарные данные.  
- **Пример:**  
  ```bash
  SET key "value"
  GET key
  ```

**2. Хеши (Hashes)**  
- **Описание:** Представление объектов с набором полей (подобно словарям/объектам).  
- **Пример:**  
  ```bash
  HSET user:1000 name "Alice" age 30
  HGETALL user:1000
  ```

**3. Списки (Lists)**  
- **Описание:** Упорядоченные коллекции элементов (подходят для очередей, стеков).  
- **Пример:**  
  ```bash
  LPUSH tasks "Task1"
  RPUSH tasks "Task2"
  LPOP tasks
  ```

**4. Множества (Sets)**  
- **Описание:** Наборы уникальных элементов без определённого порядка.  
- **Пример:**  
  ```bash
  SADD tags "redis"
  SADD tags "database"
  SMEMBERS tags
  ```

**5. Отсортированные множества (Sorted Sets)**  
- **Описание:** Множества с оценками (score), упорядоченные по ним – удобно для рейтингов и лидеров.  
- **Пример:**  
  ```bash
  ZADD leaderboard 100 "Alice"
  ZADD leaderboard 150 "Bob"
  ZRANGE leaderboard 0 -1 WITHSCORES
  ```

**6. Битовые карты (Bitmaps)**  
- **Описание:** Работа с битовыми последовательностями для флагов, подсчётов и других бинарных операций.  
- **Пример:**  
  ```bash
  SETBIT user:active:2023-01-01 100 1
  GETBIT user:active:2023-01-01 100
  ```

**7. Гиперлоглоги (HyperLogLogs)**  
- **Описание:** Приблизительный подсчёт уникальных элементов с минимальным потреблением памяти.  
- **Пример:**  
  ```bash
  PFADD visitors "192.168.0.1" "192.168.0.2"
  PFCOUNT visitors
  ```

**8. Потоки (Streams)**  
- **Описание:** Лог событий, системы обмена сообщениями, очередь событий.  
- **Пример:**  
  ```bash
  XADD mystream * sensor-id 123 temperature 19.5
  XREAD COUNT 1 STREAMS mystream 0
  ```
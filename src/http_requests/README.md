### Как устроен протокол HTTP?
- `HTTP` — это текстовый протокол, функционирующий поверх `TCP/IP`. 
- Он включает в себя запрос и ответ, которые имеют схожие структуры: стартовую строку, заголовки и тело. 
- Стартовая строка запроса содержит метод, путь и версию протокола, например:
- `GET /index.html HTTP/1.1` Стартовая строка ответа состоит из версии протокола, кода состояния и текстового описания ответа:
- `HTTP/1.1 200 OK` Заголовки представляют собой пары ключ-значение, такие, как `User-Agent` или `Content-Type`, и служат для передачи метаданных запроса, таких как язык пользователя, авторизация или информация о перенаправлениях. 
- Заголовок Host является обязательным в запросе.
- Тело ответа может быть пустым или содержать данные, такие как пары значений, файлы или бинарную информацию. 
- Тело всегда отделяется от заголовков пустой строкой.

### Сырой HTTP-запрос состоит из следующих частей:
1. Стартовая строка (Request Line):
   - Указывает метод (например, `GET`, `POST`), путь к ресурсу и версию протокола. 
   - Пример: `GET` `/ HTTP/1.1`
2. Заголовки (Headers):
   - Это метаданные запроса, которые передают дополнительную информацию серверу.
   - Примеры заголовков:
     - `Host: www.google.com` — указывает домен, к которому обращается клиент.
     - `User-Agent: Mozilla/5.0` — идентифицирует клиента (браузер или программу).
     - `Accept: text/html` — указывает, какие типы данных клиент может принять.
3. Пустая строка: 
   - Отделяет заголовки от тела запроса (если оно есть).
   - Пример: `\r\n`
4. Тело запроса (`Body`):
   - Используется в методах, таких как `POST` или `PUT`, для передачи данных на сервер.
   - В `GET`-запросах тело обычно отсутствует.

#### Пример сырого HTTP-запроса:
```http request
GET / HTTP/1.1
Host: www.google.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: close
```

### Сравнение HTTP/1.1 и HTTP/2

**1. Мультиплексирование**

*   **HTTP/1.1:** В HTTP/1.1, каждое TCP-соединение (это как одна полоса дороги) может обрабатывать только один HTTP-запрос (одна машина) за раз. Если нужно отправить несколько запросов, приходится создавать несколько соединений (много полос), что тратит время на установку каждого соединения.
*   **HTTP/2:** HTTP/2 позволяет нескольким запросам (машинам) использовать одно и то же TCP-соединение (одна дорога) одновременно. Это называется мультиплексированием. Запросы и ответы разбиваются на небольшие фрагменты и переплетаются в одном потоке данных. Это значительно быстрее, так как не нужно ждать завершения одного запроса, чтобы начать следующий.

**2. Сжатие заголовков**

*   **HTTP/1.1:** Заголовки HTTP (информация о запросе, такая как тип браузера, язык, и т.д.) отправляются в текстовом формате. Эти заголовки могут быть довольно объемными, и они отправляются при каждом запросе полностью, без сжатия. Это как отправлять одно и то же письмо несколько раз, не используя сокращения.
*   **HTTP/2:** HTTP/2 использует сжатие заголовков (HPACK). Заголовки сжимаются, чтобы уменьшить их размер. Кроме того, используются таблицы для хранения ранее отправленных заголовков, что позволяет избегать повторной отправки одинаковых данных. Это уменьшает объем передаваемых данных, что ускоряет загрузку страниц.

**3. Поддержка бинарного формата**

*   **HTTP/1.1:** Данные передаются в текстовом формате (ASCII). Это удобно для понимания человеком, но требует больше обработки компьютером для разбора и интерпретации.
*   **HTTP/2:** Данные передаются в бинарном формате. Это делает обработку данных более эффективной и быстрой для компьютеров, так как меньше ошибок при интерпретации и разборе данных.

**4. Приоритизация потоков**

*   **HTTP/1.1:** Запросы обрабатываются в порядке поступления или параллельно, если используется несколько соединений. Нет встроенной системы для указания важности запросов.
*   **HTTP/2:** Позволяет клиенту (браузеру) и серверу (веб-серверу) назначать приоритеты запросам. Например, изображение, которое находится в видимой части страницы, может получить более высокий приоритет, чем изображение, находящееся ниже, чтобы оно загрузилось быстрее. Это позволяет оптимизировать порядок загрузки ресурсов и улучшить восприятие скорости загрузки страницы пользователем.

**5. Поддержка Server Push**

*   **HTTP/1.1:** Сервер отправляет только те ресурсы, которые явно запросил клиент (браузер).
*   **HTTP/2:** Вводит механизм "Server Push". Сервер может "толкнуть" ресурсы (например, CSS-файлы или JavaScript), которые, как он знает, потребуются клиенту в будущем, до того, как клиент их запросит. Это позволяет уменьшить время загрузки, так как ресурсы уже готовы к использованию, когда они понадобятся. Это как если бы магазин заранее упаковывал продукты, которые вы, скорее всего, купите, чтобы ускорить вашу покупку.

**6. Улучшенное использование канала**

*   **HTTP/1.1:** TCP-соединение используется неэффективно из-за блокировок (один запрос блокирует другое) и отсутствия параллелизма (одновременной обработки нескольких запросов).
*   **HTTP/2:** За счет мультиплексирования (параллельной обработки нескольких запросов), сжатия заголовков (меньше данных для передачи) и приоритизации (оптимизации порядка загрузки) пропускная способность соединения значительно улучшается, а задержки снижаются. Это означает более быструю загрузку страниц и более отзывчивые веб-приложения.

**7. Поддержка безопасности**

*   **HTTP/1.1:** Работает как с безопасными соединениями (HTTPS), так и с небезопасными (HTTP).
*   **HTTP/2:** В большинстве случаев требует использования HTTPS. Это связано с тем, что большая часть браузеров реализовала поддержку HTTP/2 только поверх защищенных соединений (TLS/SSL), чтобы гарантировать безопасность передаваемых данных.

**В итоге:** HTTP/2 является значительно улучшенной версией HTTP/1.1, которая обеспечивает более быструю, эффективную и безопасную работу в интернете. Большинство современных браузеров и веб-серверов поддерживают HTTP/2, поэтому это стандарт де-факто для современных веб-приложений.

### Как перенаправить браузер на другую страницу:
- Минимальный ответ должен иметь статус 301 или 302. Заголовок Location указывает адрес ресурса, на который следует перейти.

```http request
HTTP/1.1 301 Moved Permanently
Location: https://www.google.com/
Content-Length: 0
```

#### Объяснение Строки состояния (Status Line)
> HTTP/1.1 301 Moved Permanently:
> - HTTP/1.1 — версия протокола HTTP
> - 301 — код состояния, указывающий, что ресурс был перемещен навсегда
> - Moved Permanently — текстовое описание кода состояния

> HTTP/1.1 302 Found:
> - HTTP/1.1 — версия протокола HTTP
> - 302 — код состояния, указывающий, что ресурс временно перемещен
> - Found — текстовое описание кода состояния

### Кэширование в HTTP
 — это способ временно сохранять ресурсы (например, картинки, CSS, JavaScript) на стороне 
браузера или прокси-сервера, чтобы не загружать их заново с сервера. 
Это ускоряет загрузку страниц и снижает нагрузку на сеть.

---

### Как работает кэширование:
1. **Первый запрос**:
   - Браузер запрашивает ресурс (например, картинку).
   - Сервер отправляет ресурс и заголовки, которые говорят, можно ли его кэшировать и на сколько времени.
   - Браузер сохраняет ресурс в кэше.

2. **Повторный запрос**:
   - Если ресурс еще "свежий" (не устарел), браузер берет его из кэша, не обращаясь к серверу.
   - Если ресурс устарел, браузер спрашивает сервер: "Изменился ли ресурс?".
     - Если нет, сервер отвечает: "Не изменился" (код 304), и браузер использует кэш.
     - Если да, сервер отправляет новый ресурс, и браузер обновляет кэш.

---

### Основные заголовки:
1. **`Cache-Control`**:
   - Управляет кэшированием.
   - Примеры:
     - `max-age=3600` — кэшировать на 1 час.
     - `no-cache` — кэшировать, но проверять актуальность.
     - `no-store` — не кэшировать (для секретных данных).
     - `public` — можно кэшировать везде.
     - `private` — только в браузере.

2. **`ETag`**:
   - Уникальный "отпечаток" ресурса.
   - Браузер спрашивает: "Совпадает ли `ETag`?".
   - Если да, сервер отвечает: "Не изменился" (304).
   - Если нет, сервер отправляет новый ресурс.

3. **`Last-Modified`**:
   - Дата последней модификации ресурса.
   - Браузер спрашивает: "Изменился ли ресурс с этой даты?".
   - Если нет, сервер отвечает: "Не изменился" (304).
---

### Пример:
1. Сервер отправляет картинку с заголовками:
   ```
   Cache-Control: max-age=3600
   ETag: "abc123"
   ```
   Браузер кэширует картинку на 1 час.

2. Через 30 минут браузер использует кэш (ресурс свежий).

3. Через 2 часа (ресурс устарел) браузер спрашивает:
   ```
   If-None-Match: "abc123"
   ```
   - Если картинка не изменилась, сервер отвечает: `304 Not Modified`.
   - Если изменилась, сервер отправляет новую картинку.

---

### Зачем нужно:
- Ускоряет загрузку страниц.
- Экономит трафик.
- Снижает нагрузку на сервер.

### Проблемы:
- Если кэш настроен неправильно, браузер может использовать устаревшие данные.
- Для секретных данных нужно запрещать кэширование (`no-store`).

---

### Кэширование файлов на уровне протокола HTTP работает так:

Когда Nginx отправляет файл (например, картинку), он добавляет в заголовок ETag — это как "отпечаток" файла (MD5-хеш). 
Браузер (клиент) сохраняет этот отпечаток (хэш).

**При следующем запросе того же файла:**
- Браузер (клиент) отправляет сохраненный ETag серверу.

**Сервер проверяет:**
- Сервер сравнивает хеш с актуальной версией файла.
- Если отпечаток совпадает (файл не изменился), сервер отвечает: "304 Not Modified" (используй старую копию).
- Если отпечаток другой (файл обновился), сервер отправляет новый файл с новым ETag и кодом 200.
---

### Простыми словами:
Браузер спрашивает, изменился ли файл. Если нет — использует кэш. Если да — получает новый файл.

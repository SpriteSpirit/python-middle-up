# Python middle-up

1. Основы Python 
2. ...
3. ...
4. ...
5. ...
6. ...

## Основы Python
1. Типы данных
2. Область видимости
3. Рекурсия
4. Декораторы
5. Магические методы
6. MRO, наследование, метаклассы


## Хеш
1. [Хеш — это "отпечаток пальца" для данных](#хеш--это-отпечаток-пальца-для-данных)
2. [Особенности хеширования](#особенности-хеширования)


## Словарь
1. [Почему ключи словаря должны быть неизменяемыми?](#почему-ключи-словаря-должны-быть-неизменяемыми)
2. [Механизм хеширования](#механизм-хеширования)
3. [Причина неизменяемости ключей](#причина-неизменяемости-ключей)
4. [Механизм работы](#механизм-работы)
5. [Проверка уникальности](#проверка-уникальности)
6. [Соответствие SOLID/KISS](#solidkiss)

## Множества: set / frozenset
1. [Изменяемое сножество - set()](#множества-set--frozenset-1)
2. [Операции](#операции)

## Список в cPython
1. [](#)

## Хеш

### Хеш — это "отпечаток пальца" для данных.
- Хеш преобразует любые данные (число, строку, объект) в короткое фиксированное число (например, 123abc -> 42)
- Это помогает быстро находить, сравнивать или проверять данные.

```Python
print(hash("Привет"))  # Выведет число, например, -123456789  
print(hash(3.14))       # Выведет другое число, например, 322818021  
```

### Особенности хеширования.
- Одинаковые данные = одинаковый хеш
- Разные данные = разный хеш (но возможны коллизии)
- Нельзя превратить хеш обратно в исходные данные (это не шифрование)



## Словарь

### Почему ключи словаря должны быть неизменяемыми?
- Хеш-таблицы под капотом словарей используют хеш-ключи для быстрого доступа.
- Если ключ изменится, то его хеш тоже изменится, что нарушит структуру данных.
- Кортеж (`tuple`) со списком внутри c изменяемыми элементами тоже не может быть ключом словаря.
-  Если класс реализует `__hash__` и `__eq__`, то его экземпляры могут быть ключами, но это рискованно, если объект изменяемый.

### Механизм хеширования.
- При добавлении ключа вычисляется его хеш, который определяет место в памяти.
- Если объект меняется, хеш не совпадает и поиск по ключу становится невозможным, что приведет к ошибкам или к потере данных.
- Ключи в словаре проходят проверку через хеш и равенство. Если два объекта имеют одинаковый хеш и равны, они считаются одинаковыми ключами.

### Причина неизменяемости ключей.
- Ключи в словаре должны быть хешируемыми и реализовывать методы `__hash__()` и `__eq__()`.
- Неизменяемые объекты (числа, строки, кортежи) гарантируют, что их хеш не изменится после добавления в словарь. 
- Изменяемые объекты (списки, словари, множества) не подходят: их изменение нарушит целостность хеш-таблицы.

### Механизм работы.
- При добавлении ключа вычисляется его хеш (через `hash(key)`)
- Хеш определяет "ячейку" в хеш-таблице для быстрого доступа.
- Если ключ изменить после добавления, его хеш перестанет совпадать с сохраненным и данные станут недоступны.

`Работает:`
```Python
d = {}
d[("имя", "фамилия")] = "Иван Иванов"  # Кортеж (неизменяем) как ключ
d[42] = "ответ"  # int как ключ
```

`Не работает:`
```Python
d = {}
key = [1, 2, 3]
d[key] = "список"  # TypeError: list is unhashable
```

### Проверка уникальности.
- Ключи сравниваются сначала по хешу, затем через `__eq__()`
- Даже если хеши совпадают (коллизия), проверка `a == b` исключит дубликаты.

### SOLID/KISS
- Интерфейс (__hash__, __eq__) — соблюдает принцип абстракции (`SOLID`).
- Простота (`KISS`): неизменяемость ключей упрощает логику работы словарей.

### Итог:
- Неизменяемые ключи гарантируют стабильность хеша и предотвращают ошибки доступа к данным.
- Изменяемые ключи ломают хеш-таблицу и Python запрещает их использование.


## Множества: set / frozenset.
- `set` - неупорядоченная коллекция уникальных элементов
- `frozenset` - неизменяемая неупорядоченная коллекция уникальных элементов
- Отличие `frozenset` от `set` в неизменяемости первого. После создания нельзя добавить, удалить или изменить элементы. 
- `frozenset` можно использовать как ключ словаря
- `frozenset` за счет фиксированной структуры работает быстрее.

### Операции

`Создание:`
```Python
s = {1, 2, 3}          # обычный set
fs = frozenset({1, 2, 3})  # frozenset
```

`Изменение:`
```Python
s.add(4)      # OK
fs.add(4)     # Ошибка: AttributeError (неизменяемый!)
```

`Использование как ключа:`
```Python
d = {}
d[fs] = "ключ-frozenset"  # Работает
d[s] = "ключ-set"       # Ошибка: TypeError (set не хешируем)
```

`Удаление:`
```Python
# Обычный set — можно удалять
my_set = {1, 2, 3}
my_set.remove(2)  # Удаляем элемент 2
print(my_set)     # Выведет: {1, 3}

# Попытка удалить из frozenset — ошибка
my_frozenset = frozenset({1, 2, 3})
my_frozenset.remove(1)  # AttributeError: 'frozenset' object has no attribute 'remove'
```

`Методы удаления:`
- Для `set`: `remove()`, `discard()`, `pop()` работают.
- Для `frozenset`: нет методов удаления.


### Список в cPython

- Реализован как динамический массив указателей на объекты.
- Они могут менять размер при добавлении или удалении элементов.
- Динамический массив эффективен для доступа по индексу O(1), но вставка/удаление в начале могут быть `O(n)` из-за сдвига элементов.
- Список представлен структурой `PyListObject`, которая содержит указатель на массив указателей элементов (`ob_item`), размер списка (`allocated`) и текущее количество элементов (`obj_size`).
Это позволяет эффективно управлять памятью, предварительно выделяя больше места, чем нужно, чтобы уменьшить количество перераспределений памяти. 
> `ob_item`: Массив указателей (хранит элементы).
> 
> `ob_size`: Текущее количество элементов.
> 
> `allocated`: Сколько памяти выделено (часто больше `ob_size` для быстрого добавления).
> 

### Как происходит добавление элементов.
- Если есть свободное место (`allocated > ob_size`), элемент помещается в свободную ячейку. 
- Если нет, то происходит увеличение размера массива (обычно наращивание на `~12.5%`, чтобы минимизировать операции `realloc`)

```text
struct PyListObject {
    PyObject **ob_item;  // массив элементов
    Py_ssize_t ob_size;  // текущий размер
    Py_ssize_t allocated; // выделенная память
};
```

### Как работает добавление элементов.
- Есть свободное место (`allocated > ob_size`) -> добавляется в конец списка за `O(1)`
- Нет свободного места:
1) Выделяется новый массив (обычно `new_allocated = (allocated * 3) // 2 * 1`)
2) Старые элементы копируются в новый массив.
3) Новый элемент добавляется в конец. 

```Python
lst = [1, 2, 3]   # allocated = 3, ob_size = 3
lst.append(4)     # allocated становится 6, ob_size = 4
```
### Амортизированная сложность O(1)
Даже при редких перераспределениях памяти, средняя стоимость добавления в конец остается `O(1)`.
(Это как платить за переезд в большую квартиру раз в 10 лет, но каждый день тратить копейки)

### Доступ и операции.
* По индексу: `O(1)` (прямой доступ через ob_item[index]).
* Вставка/удаление в начале: `O(n)` (нужно сдвигать элементы).
* Срезы: Создают новый список (копирование части массива).

`Пример скорости:`
```Python
lst = [1, 2, 3]
print(lst[1])     # O(1) → 2
lst.insert(0, 0)  # O(n) → [0, 1, 2, 3]
```

### Итог
Списки в `CPython` — это динамические массивы с оптимизированным управлением памяти. 
Быстры для добавления в конец и доступа по индексу, но медленны для вставки в начало.


## Асинхронное программирование (async/await):
- Это стиль программирования, где задачи могут быть приостановлены и возобновлены без блокировки всего процесса. Не использует несколько потоков.
- В Python для этого используются ключевые слова async и await. 
- Пример: если у вас есть программа, которая загружает файл с интернета, вместо того чтобы ждать, пока загрузка завершится, вы можете начать загружать другой файл или выполнять другую работу, а потом вернуться к первому файлу, когда загрузка завершится.
- Это особенно полезно для операций ввода-вывода (I/O), таких как работа с сетью или файлами, где основное время тратится на ожидание ответа.

### Для чего использоуется async и await?
- Ключевое слово async используется для определения асинхронной функции, которая может быть приостановлена для выполнения других задач.
- await используется для ожидания завершения асинхронной операции. 
- Функция, вызываемая с await, должна быть асинхронной.

### Как работают asyncio.gather, asyncio.run, asyncio.sleep, syncio.create_task?
- asyncio.gather() позволяет запускать несколько асинхронных задач одновременно и ждать их завершения.
- asyncio.run() запускает асинхронную функцию в событийном цикле (event loop).
- asyncio.sleep() позволяет приостановить выполнение асинхронной задачи на определенное время без блокировки всего потока.
- asyncio.create_task() позволяет создать задачу для параллельного выполнения без ожидания немедленного завершения.

### Что такое event loop?
- **Событийный цикл** — это механизм, который управляет выполнением асинхронных задач в Python. 
- Он следит за тем, какие задачи готовы к выполнению (например, после завершения ввода-вывода) и запускает их.

- Исключения в асинхронных функциях обрабатываются так же, как и в обычных, с помощью блоков `try` и `except`
- Асинхронные задачи полезны в приложениях, где требуется выполнение ввода-вывода (например, сетевые запросы, работа с файлами) или когда приложение должно продолжать работу во время ожидания внешних событий.

- Пример использования в реальных приложениях:
- Веб-серверы, которые обрабатывают несколько запросов одновременно.
- Клиенты для работы с API, где запросы могут выполняться параллельно.

## Многопоточность (multithreading):
- Разделение работы программы на несколько потоков, которые могут выполняться параллельно в рамках одного процесса.
- В Python используется модуль threading.
- Потоки делят между собой одно и то же адресное пространство (память), что может привести к проблемам с синхронизацией доступа к данным, если не использовать механизмы блокировки (локи).
- Из-за GIL (Global Interpreter Lock) параллелизм ограничен для CPU-интенсивных задач, но полезен для I/O операций

- **GIL (Global Interpreter Lock)** — это механизм, который предотвращает выполнение более одного потока кода одновременно в интерпретаторе CPython. 
- Это ограничение особенно заметно в задачах, требующих интенсивных вычислений, поскольку даже при наличии нескольких потоков они не могут выполняться параллельно на нескольких ядрах процессора.
- **Пример влияния GIL:** Если запустить несколько потоков для вычислительных задач, из-за GIL производительность не улучшится.

- Многопоточность полезна, когда программа зависит от ввода-вывода, например, при работе с сетевыми операциями, файлами или БД.
- В таких задачах блокировка ввода-вывода приостановит только текущий поток, а другие потоки смогут продолжить работу.

- **Для обхода ограничений GIL в задачах, требующих интенсивных вычислений, можно использовать:**
    - Многопроцессорность (multiprocessing): Каждый процесс имеет свой собственный GIL, что позволяет им выполняться параллельно на разных ядрах.
    - Асинхронное программирование (asyncio): Для I/O-зависимых задач, позволяющее эффективно обрабатывать несколько операций одновременно.
- Модуль threading предоставляет интерфейс для работы с потоками в Python. С его помощью можно создавать и управлять потоками, выполнять код в параллели.
- `threading.Event `используется для управления синхронизацией потоков. Оно позволяет одному потоку сигнализировать другому, что можно продолжить выполнение.
- `ThreadPoolExecutor` — это класс, предоставляющий пул потоков, который позволяет ограничивать количество одновременно работающих потоков и автоматически управлять их запуском и завершением.
- Потоки разделяют память одного процесса и легче по ресурсам. Однако их выполнение ограничено GIL.
- Процессы имеют собственное пространство памяти и могут выполняться параллельно без ограничений GIL, но их создание и управление ими более ресурсозатратно.

### Проблемы при работе с потоками:
- Гонки за ресурсами (race conditions): Когда несколько потоков одновременно пытаются получить доступ и изменить общий ресурс без синхронизации.
- Мертвые блокировки (deadlocks): Когда два или более потоков блокируют друг друга, ожидая освобождения ресурса, которым владеет другой поток.
- Потеря производительности из-за GIL: Особенно в вычислительно интенсивных задачах.

## Многозадачность (multiprocessing):
- Это когда программа использует несколько процессов, что позволяет использовать несколько ядер процессора для параллельных вычислений.
- В Python для этого используется модуль multiprocessing.
- Каждый процесс работает в своём собственном адресном пространстве, что решает проблемы с синхронизацией данных, но усложняет обмен данными между процессами.
- Это идеально для задач, требующих больших вычислительных ресурсов, так как каждый процесс может работать на отдельном ядре процессора.

## Ключевые различия:
- Асинхронность - это о том, как сделать программу более отзывчивой за счет переключения между задачами, особенно при работе с I/O. 
- Многопоточность - это о параллельности внутри одного процесса, но с ограничениями из-за GIL в Python.
- Многозадачность - это о настоящем параллелизме на уровне процессов, что лучше для CPU-интенсивных задач.





